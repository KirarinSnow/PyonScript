%!PS

% PyonScript programming language
% Procedure definitions


% TODO: needs more stuff

% Aliases for existing PostScript procedures and operators

<<
%   (alias)	(equivalent)

%   Dictionary operations
    /define	/def
    /set!	/store

%   Boolean literals
    /#t		/true
    /#f		/false

%   Numerical operations
    /+		/add
    /-		/sub
    /*		/mul
    /ash	/bitshift
    /quotient	/idiv
    /remainder	/mod
    /expt	/exp
>>
{
    load def
} forall



% NEW DEFINITIONS

% Constants

% Infinities
/inf.0 65536 dup exp def
/+inf.0 inf.0 def
/-inf.0 inf.0 neg def

% Limits
/ARRAYMAX 65536 def
/STRINGMAX 65536 def




% Control structures

% @ -- create a procedure from an array of S-expressions or a single object
%   array @ -> proc
%   obj @ -> proc
/@
{
    dup type /arraytype eq
    {
	[ exch
	{
	    cvlit {pyon} aload pop
	} forall
	] cvx
    }
    {
	[ exch cvlit {cvx exec} aload pop ] cvx
    } ifelse
} bind odef

% control structures with @ applied to procedure arguments, for convenience
/@for {@ for} bind odef
/@repeat {@ repeat} bind odef
/@loop {@ loop} bind odef
/@if {@ if} bind odef
/@ifelse {@ exch @ exch ifelse} bind odef

% : -- create procedure that executes a given object and returns itself
%      (executable quine with side effects)
%      given an input X, produces the procedure
%          {X exec [{X exec [aload 7 1 roll] cvx} aload 7 1 roll] cvx}
%   proc : -> proc
/:
{
    [ exch {exec [} aload pop
	[ 3 index
	    {exec [ aload 7 1 roll ] cvx} aload pop
	] cvx
	{aload 7 1 roll ] cvx} aload pop
    ] cvx
} bind odef



% Various operations

% sel -- select from two alternatives without executing (cf. ifelse)
%   bool obj1 obj2 sel -> obj
/sel
{
    3 2 roll not {exch} if pop
} bind odef

% cat -- concatenate two composite objects
%        for dictionary, second dictionary overwrites bindings in first
%   string1 string2 cat -> string
%   array1 array2 cat -> array
%   dict1 dict2 cat -> dict
/cat
{
    dup string?
    {
	concatstrings
    }
    {
	dup array?
	{
	    [ [ 4 2 roll ]
	    { aload pop } forall
	    ]
	}
	{
	    dup dict?
	    {
		<< >> 3 2 roll exch copy copy
	    }
	    {
		add
	    } ifelse
	} ifelse
    } ifelse
} bind odef


% Type operations

% boolean? -- return whether an argument is a boolean
%   obj boolean? -> bool
/boolean?
{
    type /booleantype eq
} bind odef

% number? -- return whether an argument is a number
%   obj number? -> bool
/number?
{
    type dup /integertype eq exch /realtype eq or
} bind odef

% real? -- return whether an argument is a real
%   obj real? -> bool
/real?
{
    type /realtype eq
} bind odef

% integer? -- return whether an argument is an integer
%   obj integer? -> bool
/integer?
{
    type /integertype eq
} bind odef

% name? -- return whether an argument is a name
%   obj name? -> bool
/name?
{
    type /nametype eq
} bind odef

% string? -- return whether an argument is a string
%   obj string? -> bool
/string?
{
    type /stringtype eq
} bind odef

% array? -- return whether an argument is an array
%   obj array? -> bool
/array?
{
    type /arraytype eq
} bind odef

% dict? -- return whether an argument is a dictionary
%   obj dict? -> bool
/dict?
{
    type /dicttype eq
} bind odef

% file? -- return whether an argument is a file
%   obj file? -> bool
/file?
{
    type /filetype eq
} bind odef

% operator? -- return whether an argument is an operator
%   obj operator? -> bool
/operator?
{
    type /operatortype eq
} bind odef


% Numerical operations

% zero? -- return whether an argument is zero
%   num zero? -> bool
/zero?
{
    0 eq
} bind odef

% positive? -- return whether an argument is positive
%   num positive? -> bool
/positive?
{
    0 gt
} bind odef

% negative? -- return whether an argument is negative
%   num negative? -> bool
/negative?
{
    0 lt
} bind odef

% odd? -- return whether an argument is odd
%   int odd? -> bool
/odd?
{
    2 mod 0 ne
} bind odef

% even? -- return whether an argument is even
%   int even? -> bool
/even?
{
    2 mod 0 eq
} bind odef

% modulo -- return modulo with same sign as int2
%   int1 int2 modulo -> int
/modulo
{
    2 copy mul 0 lt
    {
	dup 3 1 roll mod add
    }
    {
	mod
    } ifelse
} bind odef

% gcd -- return greatest common divisor
%   int1 int2 gcd -> int
/gcd
{
    % positivize
    abs cvi exch abs cvi exch
    % using binary GCD algorithm
    2 copy mul 0 eq
    {
	add
    }
    {
	0 3 1 roll % shift: s u v
	{
	    2 copy or 1 and 0 ne {exit} if
	    -1 bitshift exch -1 bitshift exch
	    3 -1 roll 1 add 3 1 roll
	} loop
	exch
	{
	    dup 1 and 0 ne {exit} if
	    -1 bitshift
	} loop
	exch
	{
	    {
		dup 1 and 0 ne {exit} if
		-1 bitshift
	    } loop
	    2 copy lt
	    {
		1 index sub
	    }
	    {
		2 copy sub 3 2 roll pop
	    } ifelse
	    -1 bitshift
	    dup 0 eq {exit} if
	} loop
	pop exch bitshift
    } ifelse
} bind odef

% lcm -- return lowest common multiple
%   int1 int2 lcm -> int
/lcm
{
    2 copy mul abs 3 1 roll gcd idiv
} bind odef


% Pair and list operations

% pair? -- returns whether object is a pair (2-element array)
%   obj pair? -> bool
/pair?
{
    dup type /arraytype eq
    exch length 2 eq and
} bind odef

% cons -- create a pair from two arguments
%   obj1 obj2 cons -> pair
/cons
{
    [ 3 1 roll ]
} bind odef

% car -- return first item in pair
%   pair car -> obj
/car
{
    0 get
} bind odef

% cdr -- return second item in pair
%   pair cdr -> obj
/cdr
{
    1 get
} bind odef

% set-car! -- set first item in pair
%   pair obj set-car! -> -
/set-car!
{
    0 exch put
} bind odef

% set-cdr! -- set second item in pair
%   pair obj set-cdr! -> -
/set-cdr!
{
    1 exch put
} bind odef

% caar ... cddddr -- retrieve appropriate item in nested pair
%   pair c...r -> obj
/caar {car car} bind odef
/cadr {cdr car} bind odef
/cdar {car cdr} bind odef
/cddr {cdr cdr} bind odef
/caaar {car car car} bind odef
/caadr {cdr car car} bind odef
/cadar {car cdr car} bind odef
/caddr {cdr cdr car} bind odef
/cdaar {car car cdr} bind odef
/cdadr {cdr car cdr} bind odef
/cddar {car cdr cdr} bind odef
/cdddr {cdr cdr cdr} bind odef
/caaaar {car car car car} bind odef
/caaadr {cdr car car car} bind odef
/caadar {car cdr car car} bind odef
/caaddr {cdr cdr car car} bind odef
/cadaar {car car cdr car} bind odef
/cadadr {cdr car cdr car} bind odef
/caddar {car cdr cdr car} bind odef
/cadddr {cdr cdr cdr car} bind odef
/cdaaar {car car car cdr} bind odef
/cdaadr {cdr car car cdr} bind odef
/cdadar {car cdr car cdr} bind odef
/cdaddr {cdr cdr car cdr} bind odef
/cddaar {car car cdr cdr} bind odef
/cddadr {cdr car cdr cdr} bind odef
/cdddar {car cdr cdr cdr} bind odef
/cddddr {cdr cdr cdr cdr} bind odef

% null? -- return whether an object is the empty list (empty array)
%   obj null? -> bool
/null?
{
    [] eq
} bind odef

% list? -- return whether an object is a list
%   obj list? -> bool
/list?
{
    {
	dup null? {pop true exit} if % reached empty list, finish
	dup type /arraytype eq
	{
	    dup length 2 eq
	    {
		cdr % retrieve cdr, continue
	    }
	    {
		pop false exit % non-list array
	    } ifelse
	}
	{
	    pop false exit % not an array
	} ifelse
    } loop
} bind odef

% list -- create a list out of all objects above topmost mark on operand stack
%   mark obj0 ... obj(n-1) list -> list
/list
{
    ]
    dup length exch
    {[ 3 1 roll exch} forall
    [] exch {]} repeat
} bind odef

% list-length -- length of list
%  list list-length -> int
/list-length
{
    0 exch
    {
	dup null? {pop exit} if
	cdr
	exch 1 add exch
    } loop
} bind odef

% list-append -- append two lists
%  list1 list2 list-append -> list
/list-append
{
    [ 3 2 roll  % list2 [ list1
    {
	dup null? {pop exit} if
	aload pop
    } loop
    counttomark 2 add -1 roll   % [ <list1 contents> list2
    {
	dup null? {pop exit} if
	aload pop
    } loop
    list % make list
} bind odef

% list-reverse -- reverse list
%   list list-reverse -> list
/list-reverse
{
    [ exch
    {
	dup null? {pop exit} if
	aload pop
	exch counttomark 1 roll
    } loop
    list
} bind odef

% list-tail -- return sublist obtained by omitting given number of elements
%   list num list-tail -> list
/list-tail
{
    {
	dup zero? {pop exit} if
	exch cdr exch 1 sub
    } loop
} bind odef

% list-ref -- index into list by given number (zero-indexed)
%   list num list-ref -> obj
/list-ref
{
    list-tail car
} bind odef
